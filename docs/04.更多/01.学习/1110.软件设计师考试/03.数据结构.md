---
title: 数据结构
date: 2022-01-20 11:14:20
permalink: /pages/b57d31/
categories:
  - 更多
  - 学习
  - 软件设计师考试
tags:
  -
---

## 线性结构

线性结构是最基本的数据结构，线性结构的特点是数据元素之间呈现一种线性关系。`元素一个接着一个排列`

### 线性表

线性表是最简单最基础最常用的一种线性结构。采用的是`顺序存储`和`链式存储`，主要的基本操作是插入，删除，查找。

1.  定义：
    一个线性表是 n(n>=0)个元素的有序排列，一个非空线性表的特点：  
    (1). 存在唯一的一个称作“第一个”的元素。`(开始节点)`  
    (2). 存在唯一的一个称作“最后一个”的元素。`(结束节点)`  
    (3). 除了第一个元素以外，序列中的每个元素均只有一个直接前驱。  
    (4). 除了最后一个元素以外，序列中的每个元素均只有一个直接后继。

    如下面数据中的元素`3`：

         | ... | 1 | 2 | `3` | 4 | 5 | ... |

    - 它的直接前驱是 2，它的前驱元素有两个 1，3。前驱元素指的是元素左边的部分（包含直接前驱）。
    - 它的直接后继是 4，它的后继元素有两个 4，5。后继元素指的是元素右边部分（包含后继元素）。

### 线性表的存储结构

#### 顺序储存

1.  顺序储存是什么
    将数据依次储存在，一组地址连续的储存单元里。逻辑相邻的两个元素在物理地址上也相邻。  
    如：

                  | ... |
                  |  1  |
                  |  2  |
                  |  3  |
                  | ... |

2.  顺序储存的优点
    可以随机存取表中的元素。
3.  顺序储存的缺点
    插入和删除操作需要移动元素。插入元素之前要移动元素挪出空的存储单元，然后再插入元素。删除的时候移动元素，填充被删除的元素空出来的储存单元。

#### 链式存储

1.  链式存储是什么
    通过指针链接起来的节点存储数据元素。基本的节点结构：

                  |----------|----------|
                  |  数据域   |  指针域  |
                  |----------|----------|

                   `数据域：`储存数据元素的指
                   `指针域：`储存当前元素的直接前驱或直接后继的位置信息
                   指针中的信息称为指针（或链）

    因为储存各元素的节点地址不要求是连续的，因为存储数据元素的同时必须存储元素之间的逻辑关系。节点空间只有再需要的时候才申请，不需要事先分配。

2.  线性链表
    节点之间通过指针域构成一个链表，如果节点中只有一个指针域，则称为线性链表（单链表）。
3.  链表的基本操作

    ```c
    // 声明节点结构
    typedef struct Node {
      int data; // 储存整形元素
      struct Node*next; // 指向直接后继元素的指针
    } node;

    // 创建链表的函数
    node * initLint() {
      node * p =(node*)malloc(sizeof(node)); // 创建节点头
      node * temp =p; // 声明一个指针指向头节点，用于遍历链表
      int i = 0;

      // 生成链表
      for(i =1; i < 5; i++){
        // 创建节点并初始化
        node * a =(node*)malloc(sizeof(node));
        a->date =i;
        a->next =NULL;
        // 创建新节点与直接前驱节点的逻辑关系
        temp->next=a;
        temp=temp->next;
      }
      return p
    }

    ```

    - **插入元素**

      将新元素插入到指定的位置需要做下面两步：

      - 将新节点的 next 指针指向插入位置后的节点;
      - 将插入位置前节点的 next 指针指向插入节点;

                          |----------|-->|----------|-->|----------|
                          |current(1)|-->|current(2)|-->|current(3)|
                          |----------|-->|----------|-->|----------|
                                                      |
                                                      |
                                                      ^
                                                    |---------|
                                                    | node(2.5)| <--node 插入到 2-3 中间
                                                    |---------|

        (1). 先将 current2 的后继节点指针赋给 node 所指节点的指针域;  
         `node->next = current2->next;`  
        (2). 然后将 curreent2 所指节点的指针域修改为指向 node 所指节点;  
         `current2->next=node`


    - **删除元素**

       从链表中删除指定数据元素，就是将存有该数据元素的节点链表中摘除，释放所节点的空间。
       - 将节点从链表中摘下来;
       - 手动释放点节点，回收被节点占用的储存空间;

                          |----------|--->|----------|-x->|------------|-x->|----------|
                          |current(1)|--->|current(2)|-x->|`current(3`)|-x->|currwnt(4)|
                          |----------|--->|----------|-x->|------------|-x->|----------|
                                                              |
                                                              ^
                                                          删除current3元素
          (1). 创建临时指针q指向待删除的节点;
              `q=current(3)->next`
          (2). 修改current(3)所指及五点的指针域为指向current3所指节点的后继的后继节点，从而将元素current3所在的节点从链表中删除;
             `current3->next=current(3)->next->next`
          (3). 最后释放q所指节点的空间;
             `free(q)`



    - **查找元素（遍历）**

      链表中查找指定的数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与个节点数据域中存储的数据元素进行对比，直到对比成功或遍历至链表最末端NULL。

      如：
        ```c
        LinkList Find_List(LinkList L,int k)  { <!-- L为带头节点单链表的头指针   -->
        LinkList p; int i;
        i = 1; p = L->next; <!-- 初始化，P指向第一个元素节点，i 为计数器  -->
        while(p && i < k){ <!--  顺时针链向后查找，直到P指向第k各元素节点/p为空指针  -->
          p = p->next;
          i++;
        }
        if( p && i ==k) return p; <!--存在第k各元素且指针p指向改元素节点   -->

        return NULL; <!-- 第k个元素不存在，返回空指针  -->

        } <!--  Find_List -->
        ```

    - **更改元素**

## 栈和队列

栈和队列是程序中常用的两种数据结构，他们的逻辑结构和线性表一致。特点是，栈的运算规则是`先进先出`，队列的运算规则是`后进后出`。

### 栈

1. 栈的定义
   栈是只能通过访问它的一端来实现数据储存和检索的一种线性数据结构。栈的修改是按照`先进后出`的原则进行的，因此栈又称为`后进先除（Last In First Out）`的线性表。在栈中进行插入和删除操作的一端称为栈顶（Top），相应地，另一端称为栈底（Bottom）。不含数据元素的栈称为空栈。
2. 栈的基本运算

   (1) 初始化栈 InitStack(S): 创建一个空栈(S)。  
   (2) 判断空 isEmpty(S): 当空栈 S 为空时返回“真”，否则返回假。  
   (3) 入栈 Push(S,x): 将元素 x 加入栈顶，并更新栈顶指针。  
   (4) 出栈 Pop(S): 将栈顶元素从栈中删除，并更新栈顶指针。若需要得到栈顶元素的值，可将 Pop(S)定义为一个返回栈顶元素的函数。  
   (5) 读栈顶元素 Top(S): 返回栈顶元素的值，但不修改栈顶指针。

   在应用中尝试用上诉 5 种基本运算实现基于栈结构的问题求解。

3. 栈的储存结构

   - 顺序存储。
     栈的顺序储存是指一组地址连续的存储单元依次存储自栈顶到栈底的数据元素。同时附设指针 top 指示栈顶元素的位置。采用这种顺序存储结构的栈，也叫做顺序栈。`使用顺序存储需预先定义栈的储存空间，当一个元素入栈时，需判断栈是否满（栈里面有没有空闲单元）,如果栈满了，元素就不能入栈，因为栈的空间容量是有限的。`

   - 栈的链式存储。
     链栈，采用链表作为存储结构的栈。

- 栈的应用。
