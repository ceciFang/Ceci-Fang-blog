---
title: 正则表达式
date: 2021-10-12 11:24:42
permalink: /pages/e7976d/
categories:
  - 前端
  - JavaScript文章
tags:
  -
---

## 创建正则表达式

可以通过以下两种方法构建正则表达式:

- 使用一个正则表达式字面量，内容用两个斜杠包裹。

```js
const a = /ab+c/
```

- 调用 regExp 对象的构造函数。

```js
const a = new RegExp('ab+c')
```

## regexp 对象（内置函数）

## 元字符

- 正则表达式由两个基本字符类型组成:

  - 原义文本字符

    ```js
    const a = /ab/
    // 在字符串里面匹配ab
    ```

  - 元字符

元字符指的是在正则表达式中由有特殊含义的非字母符号

## 正则表达式中的特殊字符

```js
*  // 匹配前一个表达式0次或者多次，等价于 {0,}
?  // 匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}
$  // 匹配结束符号
^  // 匹配开始符号
.
|
\
()
{}
[]

```

\b 单词边界
. 任意字符
{} 量词，表示数量
[] 或
\d 匹配数字
^ 开始
\$ 结尾

## 字符类

一般情况正则表达式的一个字符匹配个字符。比如 abc 匹配"abc"。 对于正则匹配多个的场景，可以使用元字符[]来构建一个简单的类。(类是指符合某些特性的对象，非特指某个字符)

表达式[abc]把字符 a 或 b 或 c 归为一类，表达可以式匹配这类的字符

列:

```js
'a1b2c3d4'.replace(/[abc]/g, 'x')
```

- 字符类取反
  使用元字符^创建反向类/负向类，反向类的意思是说不属于某类的内容。  
  表达式[^abc]表示不是字符 a 或者 b 或者 c 的内容

```js
'a1b2c3d4'.replace(/[^abc]/g, 'x')
```

## 范围类

- 使用字符类匹配数字
  可以使用[a-z]来连接两个字符表示从 a 到 z 的任意字符，包含 a 和 z 本身。

  ```js
  'a1b2d3x4z8'.replace(/[a-z]/g, 'Q')
  // 'Q1Q2Q3Q4Q8'
  ```

- 大小写字母匹配
  在[] 组成的类部是可以连写的[a-zA-Z]

  ```js
  'a1b2b3x2z6HDKU34KJXb8'.replace(/[a-zA-Z]/g, 'Q')
  //'Q1Q2Q3Q2Q6QQQQ34QQQQ8'
  ```

  ::: warning
  如果横线在[0-9] 一个开头一个结尾，表示范围的意思。反之[0-9-],表示匹配所有。

  ```js
  '2021-10-17'.replace(/[0-9]/g, 'A')
  // 'AAAA-AA-AA'

  '2021-10-17'.replace(/[0-9-]/g, 'A')
  //'AAAAAAAAAA'
  ```

  :::

## 预定义类

| 字符 | 等价类          | 含义                               |
| ---- | --------------- | ---------------------------------- |
| .    | [^\r\n]         | 除了回车符号和换行符之外的所有字符 |
| \d   | [0-9]           | 数组字符                           |
| \D   | [^0-9]          | 非数字字符                         |
| \s   | [\t\n\xOB\f\r]  | 空白字符                           |
| \S   | [^\t\n\xob\f\r] | 非空白字符                         |
| \w   | [a-zA-Z_0-9]    | 单词字符(字母、数字下划线)         |
| \W   | [^a-za-z_0-9]   | 非单词字符                         |

列:  
 匹配一个 ab+数字+任意字符的字符串:ab\d.

## 边界匹配字符

| 字符 | 含义        |
| ---- | ----------- |
| ^    | 以 xxx 开始 |
| \$   | 以 xxx 结束 |
| \b   | 单词边界    |
| \B   | 非单词边界  |
| m    | 多行匹配    |

```js
// 替换@开头的字符
'@123@234@'.replace(/^@/g, 'Q')
// 'Q123@234@'

// 任意字符加@
'@123@234@'.replace(/.@/g, 'Q')
// '@12Q23Q'

// 任意字符加@结尾
'@123@234@'.replace(/.@$/g, 'Q')
// '@123@23Q'
```

## 量词

匹配一个连续出现 20 次数字的字符串: \d{20}

| 字符  | 含义                           |
| ----- | ------------------------------ |
| ?     | 出现零次或一次（最多出现一次） |
| +     | 一次或者多次（至少出席一次）   |
| \*    | 出现零次或多次（任意次）       |
| {n}   | 出现 n 次                      |
| {n,m} | 出现 n 到 m 次                 |
| {n,}  | 至少出现 n 次                  |

## 贪婪模式

让正在表达式尽可能多的匹配。

```js
'12345678'.replace(/\d{3,6}/g, 'Q')
// 'Q78'
```

## 非贪婪模式

让正则表达式尽可能少的匹配，一旦匹配不成功就不再尝试。

实现方法：`在量词后面加?`

```js
'12345678'.replace(/\d{3,6}?/g, 'Q')
// 'QQ78'
```

## 分组

场景: 匹配字符串 Byron 连续出现 3 次

解决方式：使用（）可以达到分组的功能，是量词作用于分组。

```js
'a1b2c3d4'.replace(/([a-z]\d){3}/g, 'x')
// 'xd4'
```

- 或

使用 | 可以达到或的效果

- 反向引用

替换字符是变量，不是常量

问题：2015-12-25 => 12/25/2015

```js
'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/g, '$2/$3/$1')

// '12/25/2015'
```

- 忽略分组

不希望捕获某些分组，只需要在分组内加上？:就可以了

## 前瞻

正则表达式从文本头部向尾部开始解析，文本尾部方向，称为"前"。

前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言。

Javscript 不支持后顾，符合断言成为`肯定/正向`匹配，不符合特定断言成为 `否定/负向`匹配。

- 正向前瞻：exp(?=assert)

```js
'a2*X4X8'.replace(/\w(?=\d)/g, 'Q')
// Q2*Q4Q8'

'a2*X4VV'.replace(/\w(?=\d)/g, 'Q')
// 'Q2*Q4VV'
```

- 负向前瞻： exp(?!assert)

```js
'a2*34vv'.replace(/\w(?!\d)/g, 'p')
// 'ap*3ppp'
```

## JS 对象属性

- global:是否全文搜索，默认 false
- ignore case: 是否大小写敏感，默认 false
- multiline: 多行搜索，默认值是 false
- lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置
- source: 正则表达式的文本字符串

## test/exec 方法

### test

用户测试字符串参数中是否存在匹配表达式模式的字符串，如果存在则返回 true,否则返回 false

### exec

使用正则表达式模式对字符串执行搜索，并将更新全局 RegExg 对象的属性以反映匹配结果。

如果没有匹配的文本则返回 null,否则返回一个结果数组:

    - index 声明匹配文本的第一个字符的位置
    - input 存放被见多的字符串 string
