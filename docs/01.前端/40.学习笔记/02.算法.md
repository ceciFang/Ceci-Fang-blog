---
title: 算法
date: 2021-08-30 15:57:52
permalink: /pages/fad137/
categories:
  - 前端
  - 学习笔记
tags:
  -
---

# 时间/空间复杂度计算

## 时间复杂度是什么？

- 一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN) ......
- 定性描述该算法的运行时间

### O(1)

意思是每次执行这段代码的时候，只会执行一次。代码里面没有循环哪些。

```JS
let i = 0;
i += 1
```

### O（n）

因为下面的代码执行了 n 次

```JS
for (let i = 0; i < n; i += 1>){
  console.log(i);
}
```

### O(1)+O(n) = O(n)

这个表示这个算法的时间复杂度为 O(n),因为 n 足够大的时候，1 可以忽略不计了。如果两个时间复杂度相加，取最大的时间复杂度，忽略小的。

```js
let i = 0;
i += 1;
for (let i = 0; j < n ; j += 1)
```

### O(n) \* O(n) = O(n^2)

时间复杂度相乘的计算方式是：两个 n 相乘

```js
for (let i = 0; i < n; i += 1) {
  for (let j = 0; j < n; j += 1) {
    cosnole.log(i, j)
  }
}
```

### O(logN)

实际上是以 2 为 底,log 是求 2 的多少次为 N。

```JS
let i = 1；
while ( i < n ){
  console.log(i);
  i *=2
}
```

## 空间杂度是什么？

- 一个函数，用大 O 表示，比如 O(1),O(n),O(n^2) ......
- 算法在运行过程中临时占用储存空间大小的量度，就是代码占内存的大小

### O(1)

```JS
let i = 0;
i += 1
```

### O(n)

```js
const list = []
for (let i = 0; i < n; i += 1) {
  list.push(i)
}
```

声明了一个 list 数组，数组里面添加了 n 个值,它们相当于占用了 n 个内存单元，所以说这段代码的空间复杂度为 O(n)

### O(n^2)

```JS
const matrix = [];
for (let i = 0; i <0; i +=1) {
  matrix.push([]);
  for(let j =0;j<n; j+=1){
    matrix[i].push(j);
  }
}
```

居正，居正的本质是个二维数组，它嵌套着两个数组，它存储 N 的 2 次方个变量。

# 数据结构之栈

## 栈是什么？

一个后进先出的数据结构。JavaScript 中没有栈，但可以用 Array 实现栈的所有功能。

栈常用操作: push 、pop、stack[stack.length-1]
::: tip
后进先出的意思是:栈只有一个开口，先进去的在最下面，后进来的就在前面，想要取出来的话，只能是开口端拿出去。靠近开口端的是后面进来的，所以说先进后出，后进先出。
:::

```js
// Array 模拟入栈出栈

const stack = []
stack.push(1) // 入栈
stack.push(3) // [3,1]
const item1 = stack.pop() // 出栈 [3]
const item2 = stack.pop() // [1]
```

## 栈的应用场景

需要后进先出的场景

1. 十进制转换二进制
   后出来的余数反而要排到前面

   > 把余数一次入栈，然后再出栈，就可以实现余数倒叙输出

2. 判断字符串的括号是否有效
   越靠后的左括号，对应的右括号越靠前。
   ```sh
    (((((())))))
   ```
   > 左括号入栈，右括号出栈，最后栈空了就是合法的。
3. 函数调用堆栈
   最后调用的函数，最先执行完。
   ```js
   function greeting() {
     // [1] Some codes here
     sayHi()
     // [2] Some codes here
   }
   function sayHi() {
     return 'Hi'
   }
   // 调用 `greeting` 函数
   greeting()
   // [3] Some codes here
   ```

## 题目之 leetCode: 20.有效的括号

解题思路

解题步骤:

1. 新建一个栈。
2. 扫描字符串，遇左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定不合法。
3. 最后栈空了就合法了，否则不合法

```js
function isValid(s) {
  // 判断参数的长度是否为偶数
  if (s.length % 2 === 1) return false
  const stack = []
  for (let i = 0; i < s.length; i += 1) {
    const c = s[i]
    // 左边的括号，进栈
    if (c === '(' || c === '{' || c === '[') {
      stack.push(c)
    } else {
      const t = stack[stack.length - 1] // 获取栈底的右边括号
      // 判断左右括号是否匹配
      if (
        (t === '(' && c === ')') ||
        (t === '{' && c === '}') ||
        (t === '[' && c === ']')
      ) {
        stack.pop()
      } else {
        return false
      }
    }
  }
  return stack.length === 0
}
```

- 时间复杂度: 这段代码只有一个 for 循环，for 循环里面没有循环。代码的复杂度为 O(1)，主要是 push()pop()等方法, 所以认为这段代码的时间复杂度为 O(n),n 为 s.length，即 s 字符串的长度。

- 空间复杂度：这段代码新建了一个临时变量 stack,这个 stack 在极端的情况下会把 s 所有的 s 里面的字符全部 push 进去，也就是 s 全部为左括号。stack 会占用 n 个内存单元，所有这段代码的空间复杂度为 O(n)。

::: tip 扩展

- 加法赋值运算符(+=)
  表示将右边的值添加到变量里，并将结果分配该变量。
  语法：`x+=y` => `x=x+y`
- 自增运算符 (++)
  表示将其操作数递增(1)并返回一个值。
  语法：`x++(后置自增)`|| `++x(前置自增)` => `x+1`
  :::

## 题目之 leetCode: 144.二叉树的前序遍历

## JS 中的函数调用堆栈

# 数据结构之队列

# 数据结构之链表

# 数据结构之集合

# 数据结果之字典

# 数据结果之树

# 数据结构之图

# 数据结构之堆

# 进阶算法之“搜索排序”

# 算法设计思想之“分而治之”

# 算法设计思想之“动态规划”

# 算法设计思想之“贪心算法”

# 算法设计思想之“回溯算法”

```

```
